# This file is automatically generated by Keystone, do not modify it manually.
# Modify your Keystone config when you want to change this.

type User {
  id: ID!
  name: String
  email: String
  adminUiPassword: PasswordState
  memberships(where: OrganizationWhereInput! = {}, orderBy: [OrganizationOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: OrganizationWhereUniqueInput): [Organization!]
  membershipsCount(where: OrganizationWhereInput! = {}): Int
  adminMemberships(where: OrganizationWhereInput! = {}, orderBy: [OrganizationOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: OrganizationWhereUniqueInput): [Organization!]
  adminMembershipsCount(where: OrganizationWhereInput! = {}): Int
  createdAt: DateTime
}

type PasswordState {
  isSet: Boolean!
}

scalar DateTime @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

input UserWhereUniqueInput {
  id: ID
  email: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IDFilter
  name: StringFilter
  email: StringFilter
  memberships: OrganizationManyRelationFilter
  adminMemberships: OrganizationManyRelationFilter
  createdAt: DateTimeNullableFilter
}

input IDFilter {
  equals: ID
  in: [ID!]
  notIn: [ID!]
  lt: ID
  lte: ID
  gt: ID
  gte: ID
  not: IDFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input OrganizationManyRelationFilter {
  every: OrganizationWhereInput
  some: OrganizationWhereInput
  none: OrganizationWhereInput
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: DateTimeNullableFilter
}

input UserOrderByInput {
  id: OrderDirection
  name: OrderDirection
  email: OrderDirection
  createdAt: OrderDirection
}

enum OrderDirection {
  asc
  desc
}

input UserUpdateInput {
  name: String
  email: String
  adminUiPassword: String
  memberships: OrganizationRelateToManyForUpdateInput
  adminMemberships: OrganizationRelateToManyForUpdateInput
  createdAt: DateTime
}

input OrganizationRelateToManyForUpdateInput {
  disconnect: [OrganizationWhereUniqueInput!]
  set: [OrganizationWhereUniqueInput!]
  create: [OrganizationCreateInput!]
  connect: [OrganizationWhereUniqueInput!]
}

input UserUpdateArgs {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input UserCreateInput {
  name: String
  email: String
  adminUiPassword: String
  memberships: OrganizationRelateToManyForCreateInput
  adminMemberships: OrganizationRelateToManyForCreateInput
  createdAt: DateTime
}

input OrganizationRelateToManyForCreateInput {
  create: [OrganizationCreateInput!]
  connect: [OrganizationWhereUniqueInput!]
}

type Organization {
  id: ID!
  name: String
  membersInOrganization(where: UserWhereInput! = {}, orderBy: [UserOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: UserWhereUniqueInput): [User!]
  membersInOrganizationCount(where: UserWhereInput! = {}): Int
  adminsOfOrganization(where: UserWhereInput! = {}, orderBy: [UserOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: UserWhereUniqueInput): [User!]
  adminsOfOrganizationCount(where: UserWhereInput! = {}): Int
  type: OrganizationTypeType
  eventsByOrganization(where: EventWhereInput! = {}, orderBy: [EventOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: EventWhereUniqueInput): [Event!]
  eventsByOrganizationCount(where: EventWhereInput! = {}): Int
  mapsInOrganization(where: MapWhereInput! = {}, orderBy: [MapOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: MapWhereUniqueInput): [Map!]
  mapsInOrganizationCount(where: MapWhereInput! = {}): Int
}

enum OrganizationTypeType {
  church
  soul_winning_club
}

input OrganizationWhereUniqueInput {
  id: ID
}

input OrganizationWhereInput {
  AND: [OrganizationWhereInput!]
  OR: [OrganizationWhereInput!]
  NOT: [OrganizationWhereInput!]
  id: IDFilter
  name: StringFilter
  membersInOrganization: UserManyRelationFilter
  adminsOfOrganization: UserManyRelationFilter
  type: OrganizationTypeTypeNullableFilter
  eventsByOrganization: EventManyRelationFilter
  mapsInOrganization: MapManyRelationFilter
}

input UserManyRelationFilter {
  every: UserWhereInput
  some: UserWhereInput
  none: UserWhereInput
}

input OrganizationTypeTypeNullableFilter {
  equals: OrganizationTypeType
  in: [OrganizationTypeType!]
  notIn: [OrganizationTypeType!]
  not: OrganizationTypeTypeNullableFilter
}

input EventManyRelationFilter {
  every: EventWhereInput
  some: EventWhereInput
  none: EventWhereInput
}

input MapManyRelationFilter {
  every: MapWhereInput
  some: MapWhereInput
  none: MapWhereInput
}

input OrganizationOrderByInput {
  id: OrderDirection
  name: OrderDirection
  type: OrderDirection
}

input OrganizationUpdateInput {
  name: String
  membersInOrganization: UserRelateToManyForUpdateInput
  adminsOfOrganization: UserRelateToManyForUpdateInput
  type: OrganizationTypeType
  eventsByOrganization: EventRelateToManyForUpdateInput
  mapsInOrganization: MapRelateToManyForUpdateInput
}

input UserRelateToManyForUpdateInput {
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input EventRelateToManyForUpdateInput {
  disconnect: [EventWhereUniqueInput!]
  set: [EventWhereUniqueInput!]
  create: [EventCreateInput!]
  connect: [EventWhereUniqueInput!]
}

input MapRelateToManyForUpdateInput {
  disconnect: [MapWhereUniqueInput!]
  set: [MapWhereUniqueInput!]
  create: [MapCreateInput!]
  connect: [MapWhereUniqueInput!]
}

input OrganizationUpdateArgs {
  where: OrganizationWhereUniqueInput!
  data: OrganizationUpdateInput!
}

input OrganizationCreateInput {
  name: String
  membersInOrganization: UserRelateToManyForCreateInput
  adminsOfOrganization: UserRelateToManyForCreateInput
  type: OrganizationTypeType
  eventsByOrganization: EventRelateToManyForCreateInput
  mapsInOrganization: MapRelateToManyForCreateInput
}

input UserRelateToManyForCreateInput {
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input EventRelateToManyForCreateInput {
  create: [EventCreateInput!]
  connect: [EventWhereUniqueInput!]
}

input MapRelateToManyForCreateInput {
  create: [MapCreateInput!]
  connect: [MapWhereUniqueInput!]
}

type Event {
  id: ID!
  name: String
  type: EventTypeType
  coverPhotoUrl: String
  whatToExpect: String
  eventPlan: String
  organization: Organization
  soulWinningSessions(where: SoulWinningSessionWhereInput! = {}, orderBy: [SoulWinningSessionOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: SoulWinningSessionWhereUniqueInput): [SoulWinningSession!]
  soulWinningSessionsCount(where: SoulWinningSessionWhereInput! = {}): Int
  scheduledStartTimeInUtc: DateTime
  scheduledEndTimeInUtc: DateTime
}

enum EventTypeType {
  marathon
  push
}

input EventWhereUniqueInput {
  id: ID
}

input EventWhereInput {
  AND: [EventWhereInput!]
  OR: [EventWhereInput!]
  NOT: [EventWhereInput!]
  id: IDFilter
  name: StringFilter
  type: EventTypeTypeNullableFilter
  coverPhotoUrl: StringFilter
  whatToExpect: StringFilter
  eventPlan: StringFilter
  organization: OrganizationWhereInput
  soulWinningSessions: SoulWinningSessionManyRelationFilter
  scheduledStartTimeInUtc: DateTimeFilter
  scheduledEndTimeInUtc: DateTimeFilter
}

input EventTypeTypeNullableFilter {
  equals: EventTypeType
  in: [EventTypeType!]
  notIn: [EventTypeType!]
  not: EventTypeTypeNullableFilter
}

input SoulWinningSessionManyRelationFilter {
  every: SoulWinningSessionWhereInput
  some: SoulWinningSessionWhereInput
  none: SoulWinningSessionWhereInput
}

input DateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: DateTimeFilter
}

input EventOrderByInput {
  id: OrderDirection
  name: OrderDirection
  type: OrderDirection
  coverPhotoUrl: OrderDirection
  whatToExpect: OrderDirection
  eventPlan: OrderDirection
  scheduledStartTimeInUtc: OrderDirection
  scheduledEndTimeInUtc: OrderDirection
}

input EventUpdateInput {
  name: String
  type: EventTypeType
  coverPhotoUrl: String
  whatToExpect: String
  eventPlan: String
  organization: OrganizationRelateToOneForUpdateInput
  soulWinningSessions: SoulWinningSessionRelateToManyForUpdateInput
  scheduledStartTimeInUtc: DateTime
  scheduledEndTimeInUtc: DateTime
}

input OrganizationRelateToOneForUpdateInput {
  create: OrganizationCreateInput
  connect: OrganizationWhereUniqueInput
  disconnect: Boolean
}

input SoulWinningSessionRelateToManyForUpdateInput {
  disconnect: [SoulWinningSessionWhereUniqueInput!]
  set: [SoulWinningSessionWhereUniqueInput!]
  create: [SoulWinningSessionCreateInput!]
  connect: [SoulWinningSessionWhereUniqueInput!]
}

input EventUpdateArgs {
  where: EventWhereUniqueInput!
  data: EventUpdateInput!
}

input EventCreateInput {
  name: String
  type: EventTypeType
  coverPhotoUrl: String
  whatToExpect: String
  eventPlan: String
  organization: OrganizationRelateToOneForCreateInput
  soulWinningSessions: SoulWinningSessionRelateToManyForCreateInput
  scheduledStartTimeInUtc: DateTime
  scheduledEndTimeInUtc: DateTime
}

input OrganizationRelateToOneForCreateInput {
  create: OrganizationCreateInput
  connect: OrganizationWhereUniqueInput
}

input SoulWinningSessionRelateToManyForCreateInput {
  create: [SoulWinningSessionCreateInput!]
  connect: [SoulWinningSessionWhereUniqueInput!]
}

type SoulWinningSession {
  id: ID!
  name: String
  event: Event
  groups(where: SoulWinningSessionGroupWhereInput! = {}, orderBy: [SoulWinningSessionGroupOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: SoulWinningSessionGroupWhereUniqueInput): [SoulWinningSessionGroup!]
  groupsCount(where: SoulWinningSessionGroupWhereInput! = {}): Int
  scheduledStartTimeInUtc: DateTime
  scheduledEndTimeInUtc: DateTime
}

input SoulWinningSessionWhereUniqueInput {
  id: ID
}

input SoulWinningSessionWhereInput {
  AND: [SoulWinningSessionWhereInput!]
  OR: [SoulWinningSessionWhereInput!]
  NOT: [SoulWinningSessionWhereInput!]
  id: IDFilter
  name: StringFilter
  event: EventWhereInput
  groups: SoulWinningSessionGroupManyRelationFilter
  scheduledStartTimeInUtc: DateTimeFilter
  scheduledEndTimeInUtc: DateTimeFilter
}

input SoulWinningSessionGroupManyRelationFilter {
  every: SoulWinningSessionGroupWhereInput
  some: SoulWinningSessionGroupWhereInput
  none: SoulWinningSessionGroupWhereInput
}

input SoulWinningSessionOrderByInput {
  id: OrderDirection
  name: OrderDirection
  scheduledStartTimeInUtc: OrderDirection
  scheduledEndTimeInUtc: OrderDirection
}

input SoulWinningSessionUpdateInput {
  name: String
  event: EventRelateToOneForUpdateInput
  groups: SoulWinningSessionGroupRelateToManyForUpdateInput
  scheduledStartTimeInUtc: DateTime
  scheduledEndTimeInUtc: DateTime
}

input EventRelateToOneForUpdateInput {
  create: EventCreateInput
  connect: EventWhereUniqueInput
  disconnect: Boolean
}

input SoulWinningSessionGroupRelateToManyForUpdateInput {
  disconnect: [SoulWinningSessionGroupWhereUniqueInput!]
  set: [SoulWinningSessionGroupWhereUniqueInput!]
  create: [SoulWinningSessionGroupCreateInput!]
  connect: [SoulWinningSessionGroupWhereUniqueInput!]
}

input SoulWinningSessionUpdateArgs {
  where: SoulWinningSessionWhereUniqueInput!
  data: SoulWinningSessionUpdateInput!
}

input SoulWinningSessionCreateInput {
  name: String
  event: EventRelateToOneForCreateInput
  groups: SoulWinningSessionGroupRelateToManyForCreateInput
  scheduledStartTimeInUtc: DateTime
  scheduledEndTimeInUtc: DateTime
}

input EventRelateToOneForCreateInput {
  create: EventCreateInput
  connect: EventWhereUniqueInput
}

input SoulWinningSessionGroupRelateToManyForCreateInput {
  create: [SoulWinningSessionGroupCreateInput!]
  connect: [SoulWinningSessionGroupWhereUniqueInput!]
}

type SoulWinningSessionGroup {
  id: ID!
  name: String
  session: SoulWinningSession
  members(where: UserWhereInput! = {}, orderBy: [UserOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: UserWhereUniqueInput): [User!]
  membersCount(where: UserWhereInput! = {}): Int
  assignedMapArea: MapArea
  encounters(where: EncounterWhereInput! = {}, orderBy: [EncounterOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: EncounterWhereUniqueInput): [Encounter!]
  encountersCount(where: EncounterWhereInput! = {}): Int
}

input SoulWinningSessionGroupWhereUniqueInput {
  id: ID
}

input SoulWinningSessionGroupWhereInput {
  AND: [SoulWinningSessionGroupWhereInput!]
  OR: [SoulWinningSessionGroupWhereInput!]
  NOT: [SoulWinningSessionGroupWhereInput!]
  id: IDFilter
  name: StringFilter
  session: SoulWinningSessionWhereInput
  members: UserManyRelationFilter
  assignedMapArea: MapAreaWhereInput
  encounters: EncounterManyRelationFilter
}

input EncounterManyRelationFilter {
  every: EncounterWhereInput
  some: EncounterWhereInput
  none: EncounterWhereInput
}

input SoulWinningSessionGroupOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input SoulWinningSessionGroupUpdateInput {
  name: String
  session: SoulWinningSessionRelateToOneForUpdateInput
  members: UserRelateToManyForUpdateInput
  assignedMapArea: MapAreaRelateToOneForUpdateInput
  encounters: EncounterRelateToManyForUpdateInput
}

input SoulWinningSessionRelateToOneForUpdateInput {
  create: SoulWinningSessionCreateInput
  connect: SoulWinningSessionWhereUniqueInput
  disconnect: Boolean
}

input MapAreaRelateToOneForUpdateInput {
  create: MapAreaCreateInput
  connect: MapAreaWhereUniqueInput
  disconnect: Boolean
}

input EncounterRelateToManyForUpdateInput {
  disconnect: [EncounterWhereUniqueInput!]
  set: [EncounterWhereUniqueInput!]
  create: [EncounterCreateInput!]
  connect: [EncounterWhereUniqueInput!]
}

input SoulWinningSessionGroupUpdateArgs {
  where: SoulWinningSessionGroupWhereUniqueInput!
  data: SoulWinningSessionGroupUpdateInput!
}

input SoulWinningSessionGroupCreateInput {
  name: String
  session: SoulWinningSessionRelateToOneForCreateInput
  members: UserRelateToManyForCreateInput
  assignedMapArea: MapAreaRelateToOneForCreateInput
  encounters: EncounterRelateToManyForCreateInput
}

input SoulWinningSessionRelateToOneForCreateInput {
  create: SoulWinningSessionCreateInput
  connect: SoulWinningSessionWhereUniqueInput
}

input MapAreaRelateToOneForCreateInput {
  create: MapAreaCreateInput
  connect: MapAreaWhereUniqueInput
}

input EncounterRelateToManyForCreateInput {
  create: [EncounterCreateInput!]
  connect: [EncounterWhereUniqueInput!]
}

type Encounter {
  id: ID!
  group: SoulWinningSessionGroup
  houseAddress: String
  encounterTimeInUtc: DateTime
  salvations(where: SavedPersonWhereInput! = {}, orderBy: [SavedPersonOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: SavedPersonWhereUniqueInput): [SavedPerson!]
  salvationsCount(where: SavedPersonWhereInput! = {}): Int
  result: EncounterResultType
}

enum EncounterResultType {
  salvation
  listened_to_entire_gospel
  listened_to_few_verses
  not_interested
}

input EncounterWhereUniqueInput {
  id: ID
}

input EncounterWhereInput {
  AND: [EncounterWhereInput!]
  OR: [EncounterWhereInput!]
  NOT: [EncounterWhereInput!]
  id: IDFilter
  group: SoulWinningSessionGroupWhereInput
  houseAddress: StringFilter
  encounterTimeInUtc: DateTimeNullableFilter
  salvations: SavedPersonManyRelationFilter
  result: EncounterResultTypeNullableFilter
}

input SavedPersonManyRelationFilter {
  every: SavedPersonWhereInput
  some: SavedPersonWhereInput
  none: SavedPersonWhereInput
}

input EncounterResultTypeNullableFilter {
  equals: EncounterResultType
  in: [EncounterResultType!]
  notIn: [EncounterResultType!]
  not: EncounterResultTypeNullableFilter
}

input EncounterOrderByInput {
  id: OrderDirection
  houseAddress: OrderDirection
  encounterTimeInUtc: OrderDirection
  result: OrderDirection
}

input EncounterUpdateInput {
  group: SoulWinningSessionGroupRelateToOneForUpdateInput
  houseAddress: String
  encounterTimeInUtc: DateTime
  salvations: SavedPersonRelateToManyForUpdateInput
  result: EncounterResultType
}

input SoulWinningSessionGroupRelateToOneForUpdateInput {
  create: SoulWinningSessionGroupCreateInput
  connect: SoulWinningSessionGroupWhereUniqueInput
  disconnect: Boolean
}

input SavedPersonRelateToManyForUpdateInput {
  disconnect: [SavedPersonWhereUniqueInput!]
  set: [SavedPersonWhereUniqueInput!]
  create: [SavedPersonCreateInput!]
  connect: [SavedPersonWhereUniqueInput!]
}

input EncounterUpdateArgs {
  where: EncounterWhereUniqueInput!
  data: EncounterUpdateInput!
}

input EncounterCreateInput {
  group: SoulWinningSessionGroupRelateToOneForCreateInput
  houseAddress: String
  encounterTimeInUtc: DateTime
  salvations: SavedPersonRelateToManyForCreateInput
  result: EncounterResultType
}

input SoulWinningSessionGroupRelateToOneForCreateInput {
  create: SoulWinningSessionGroupCreateInput
  connect: SoulWinningSessionGroupWhereUniqueInput
}

input SavedPersonRelateToManyForCreateInput {
  create: [SavedPersonCreateInput!]
  connect: [SavedPersonWhereUniqueInput!]
}

type SavedPerson {
  id: ID!
  name: String
  email: String
  phone: String
  savingEncounter: Encounter
}

input SavedPersonWhereUniqueInput {
  id: ID
  email: String
}

input SavedPersonWhereInput {
  AND: [SavedPersonWhereInput!]
  OR: [SavedPersonWhereInput!]
  NOT: [SavedPersonWhereInput!]
  id: IDFilter
  name: StringFilter
  email: StringFilter
  phone: StringFilter
  savingEncounter: EncounterWhereInput
}

input SavedPersonOrderByInput {
  id: OrderDirection
  name: OrderDirection
  email: OrderDirection
  phone: OrderDirection
}

input SavedPersonUpdateInput {
  name: String
  email: String
  phone: String
  savingEncounter: EncounterRelateToOneForUpdateInput
}

input EncounterRelateToOneForUpdateInput {
  create: EncounterCreateInput
  connect: EncounterWhereUniqueInput
  disconnect: Boolean
}

input SavedPersonUpdateArgs {
  where: SavedPersonWhereUniqueInput!
  data: SavedPersonUpdateInput!
}

input SavedPersonCreateInput {
  name: String
  email: String
  phone: String
  savingEncounter: EncounterRelateToOneForCreateInput
}

input EncounterRelateToOneForCreateInput {
  create: EncounterCreateInput
  connect: EncounterWhereUniqueInput
}

type Map {
  id: ID!
  name: String
  belongingOrganization: Organization
  areas(where: MapAreaWhereInput! = {}, orderBy: [MapAreaOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: MapAreaWhereUniqueInput): [MapArea!]
  areasCount(where: MapAreaWhereInput! = {}): Int
}

input MapWhereUniqueInput {
  id: ID
}

input MapWhereInput {
  AND: [MapWhereInput!]
  OR: [MapWhereInput!]
  NOT: [MapWhereInput!]
  id: IDFilter
  name: StringFilter
  belongingOrganization: OrganizationWhereInput
  areas: MapAreaManyRelationFilter
}

input MapAreaManyRelationFilter {
  every: MapAreaWhereInput
  some: MapAreaWhereInput
  none: MapAreaWhereInput
}

input MapOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input MapUpdateInput {
  name: String
  belongingOrganization: OrganizationRelateToOneForUpdateInput
  areas: MapAreaRelateToManyForUpdateInput
}

input MapAreaRelateToManyForUpdateInput {
  disconnect: [MapAreaWhereUniqueInput!]
  set: [MapAreaWhereUniqueInput!]
  create: [MapAreaCreateInput!]
  connect: [MapAreaWhereUniqueInput!]
}

input MapUpdateArgs {
  where: MapWhereUniqueInput!
  data: MapUpdateInput!
}

input MapCreateInput {
  name: String
  belongingOrganization: OrganizationRelateToOneForCreateInput
  areas: MapAreaRelateToManyForCreateInput
}

input MapAreaRelateToManyForCreateInput {
  create: [MapAreaCreateInput!]
  connect: [MapAreaWhereUniqueInput!]
}

type MapArea {
  id: ID!
  name: String
  belongingMap: Map
  polygonGeoJson: JSON
}

input MapAreaWhereUniqueInput {
  id: ID
}

input MapAreaWhereInput {
  AND: [MapAreaWhereInput!]
  OR: [MapAreaWhereInput!]
  NOT: [MapAreaWhereInput!]
  id: IDFilter
  name: StringFilter
  belongingMap: MapWhereInput
}

input MapAreaOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input MapAreaUpdateInput {
  name: String
  belongingMap: MapRelateToOneForUpdateInput
  polygonGeoJson: JSON
}

input MapRelateToOneForUpdateInput {
  create: MapCreateInput
  connect: MapWhereUniqueInput
  disconnect: Boolean
}

input MapAreaUpdateArgs {
  where: MapAreaWhereUniqueInput!
  data: MapAreaUpdateInput!
}

input MapAreaCreateInput {
  name: String
  belongingMap: MapRelateToOneForCreateInput
  polygonGeoJson: JSON
}

input MapRelateToOneForCreateInput {
  create: MapCreateInput
  connect: MapWhereUniqueInput
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Mutation {
  createUser(data: UserCreateInput!): User
  createUsers(data: [UserCreateInput!]!): [User]
  updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User
  updateUsers(data: [UserUpdateArgs!]!): [User]
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUsers(where: [UserWhereUniqueInput!]!): [User]
  createOrganization(data: OrganizationCreateInput!): Organization
  createOrganizations(data: [OrganizationCreateInput!]!): [Organization]
  updateOrganization(where: OrganizationWhereUniqueInput!, data: OrganizationUpdateInput!): Organization
  updateOrganizations(data: [OrganizationUpdateArgs!]!): [Organization]
  deleteOrganization(where: OrganizationWhereUniqueInput!): Organization
  deleteOrganizations(where: [OrganizationWhereUniqueInput!]!): [Organization]
  createEvent(data: EventCreateInput!): Event
  createEvents(data: [EventCreateInput!]!): [Event]
  updateEvent(where: EventWhereUniqueInput!, data: EventUpdateInput!): Event
  updateEvents(data: [EventUpdateArgs!]!): [Event]
  deleteEvent(where: EventWhereUniqueInput!): Event
  deleteEvents(where: [EventWhereUniqueInput!]!): [Event]
  createSoulWinningSession(data: SoulWinningSessionCreateInput!): SoulWinningSession
  createSoulWinningSessions(data: [SoulWinningSessionCreateInput!]!): [SoulWinningSession]
  updateSoulWinningSession(where: SoulWinningSessionWhereUniqueInput!, data: SoulWinningSessionUpdateInput!): SoulWinningSession
  updateSoulWinningSessions(data: [SoulWinningSessionUpdateArgs!]!): [SoulWinningSession]
  deleteSoulWinningSession(where: SoulWinningSessionWhereUniqueInput!): SoulWinningSession
  deleteSoulWinningSessions(where: [SoulWinningSessionWhereUniqueInput!]!): [SoulWinningSession]
  createSoulWinningSessionGroup(data: SoulWinningSessionGroupCreateInput!): SoulWinningSessionGroup
  createSoulWinningSessionGroups(data: [SoulWinningSessionGroupCreateInput!]!): [SoulWinningSessionGroup]
  updateSoulWinningSessionGroup(where: SoulWinningSessionGroupWhereUniqueInput!, data: SoulWinningSessionGroupUpdateInput!): SoulWinningSessionGroup
  updateSoulWinningSessionGroups(data: [SoulWinningSessionGroupUpdateArgs!]!): [SoulWinningSessionGroup]
  deleteSoulWinningSessionGroup(where: SoulWinningSessionGroupWhereUniqueInput!): SoulWinningSessionGroup
  deleteSoulWinningSessionGroups(where: [SoulWinningSessionGroupWhereUniqueInput!]!): [SoulWinningSessionGroup]
  createEncounter(data: EncounterCreateInput!): Encounter
  createEncounters(data: [EncounterCreateInput!]!): [Encounter]
  updateEncounter(where: EncounterWhereUniqueInput!, data: EncounterUpdateInput!): Encounter
  updateEncounters(data: [EncounterUpdateArgs!]!): [Encounter]
  deleteEncounter(where: EncounterWhereUniqueInput!): Encounter
  deleteEncounters(where: [EncounterWhereUniqueInput!]!): [Encounter]
  createSavedPerson(data: SavedPersonCreateInput!): SavedPerson
  createSavedPeople(data: [SavedPersonCreateInput!]!): [SavedPerson]
  updateSavedPerson(where: SavedPersonWhereUniqueInput!, data: SavedPersonUpdateInput!): SavedPerson
  updateSavedPeople(data: [SavedPersonUpdateArgs!]!): [SavedPerson]
  deleteSavedPerson(where: SavedPersonWhereUniqueInput!): SavedPerson
  deleteSavedPeople(where: [SavedPersonWhereUniqueInput!]!): [SavedPerson]
  createMap(data: MapCreateInput!): Map
  createMaps(data: [MapCreateInput!]!): [Map]
  updateMap(where: MapWhereUniqueInput!, data: MapUpdateInput!): Map
  updateMaps(data: [MapUpdateArgs!]!): [Map]
  deleteMap(where: MapWhereUniqueInput!): Map
  deleteMaps(where: [MapWhereUniqueInput!]!): [Map]
  createMapArea(data: MapAreaCreateInput!): MapArea
  createMapAreas(data: [MapAreaCreateInput!]!): [MapArea]
  updateMapArea(where: MapAreaWhereUniqueInput!, data: MapAreaUpdateInput!): MapArea
  updateMapAreas(data: [MapAreaUpdateArgs!]!): [MapArea]
  deleteMapArea(where: MapAreaWhereUniqueInput!): MapArea
  deleteMapAreas(where: [MapAreaWhereUniqueInput!]!): [MapArea]
  endSession: Boolean!
  authenticateUserWithPassword(email: String!, adminUiPassword: String!): UserAuthenticationWithPasswordResult
  createInitialUser(data: CreateInitialUserInput!): UserAuthenticationWithPasswordSuccess!
}

union UserAuthenticationWithPasswordResult = UserAuthenticationWithPasswordSuccess | UserAuthenticationWithPasswordFailure

type UserAuthenticationWithPasswordSuccess {
  sessionToken: String!
  item: User!
}

type UserAuthenticationWithPasswordFailure {
  message: String!
}

input CreateInitialUserInput {
  name: String
  email: String
  adminUiPassword: String
}

type Query {
  users(where: UserWhereInput! = {}, orderBy: [UserOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: UserWhereUniqueInput): [User!]
  user(where: UserWhereUniqueInput!): User
  usersCount(where: UserWhereInput! = {}): Int
  organizations(where: OrganizationWhereInput! = {}, orderBy: [OrganizationOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: OrganizationWhereUniqueInput): [Organization!]
  organization(where: OrganizationWhereUniqueInput!): Organization
  organizationsCount(where: OrganizationWhereInput! = {}): Int
  events(where: EventWhereInput! = {}, orderBy: [EventOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: EventWhereUniqueInput): [Event!]
  event(where: EventWhereUniqueInput!): Event
  eventsCount(where: EventWhereInput! = {}): Int
  soulWinningSessions(where: SoulWinningSessionWhereInput! = {}, orderBy: [SoulWinningSessionOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: SoulWinningSessionWhereUniqueInput): [SoulWinningSession!]
  soulWinningSession(where: SoulWinningSessionWhereUniqueInput!): SoulWinningSession
  soulWinningSessionsCount(where: SoulWinningSessionWhereInput! = {}): Int
  soulWinningSessionGroups(where: SoulWinningSessionGroupWhereInput! = {}, orderBy: [SoulWinningSessionGroupOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: SoulWinningSessionGroupWhereUniqueInput): [SoulWinningSessionGroup!]
  soulWinningSessionGroup(where: SoulWinningSessionGroupWhereUniqueInput!): SoulWinningSessionGroup
  soulWinningSessionGroupsCount(where: SoulWinningSessionGroupWhereInput! = {}): Int
  encounters(where: EncounterWhereInput! = {}, orderBy: [EncounterOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: EncounterWhereUniqueInput): [Encounter!]
  encounter(where: EncounterWhereUniqueInput!): Encounter
  encountersCount(where: EncounterWhereInput! = {}): Int
  savedPeople(where: SavedPersonWhereInput! = {}, orderBy: [SavedPersonOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: SavedPersonWhereUniqueInput): [SavedPerson!]
  savedPerson(where: SavedPersonWhereUniqueInput!): SavedPerson
  savedPeopleCount(where: SavedPersonWhereInput! = {}): Int
  maps(where: MapWhereInput! = {}, orderBy: [MapOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: MapWhereUniqueInput): [Map!]
  map(where: MapWhereUniqueInput!): Map
  mapsCount(where: MapWhereInput! = {}): Int
  mapAreas(where: MapAreaWhereInput! = {}, orderBy: [MapAreaOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: MapAreaWhereUniqueInput): [MapArea!]
  mapArea(where: MapAreaWhereUniqueInput!): MapArea
  mapAreasCount(where: MapAreaWhereInput! = {}): Int
  keystone: KeystoneMeta!
  authenticatedItem: AuthenticatedItem
}

union AuthenticatedItem = User

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
  lists: [KeystoneAdminUIListMeta!]!
  list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
  key: String!
  itemQueryName: String!
  listQueryName: String!
  hideCreate: Boolean!
  hideDelete: Boolean!
  path: String!
  label: String!
  singular: String!
  plural: String!
  description: String
  initialColumns: [String!]!
  pageSize: Int!
  labelField: String!
  fields: [KeystoneAdminUIFieldMeta!]!
  groups: [KeystoneAdminUIFieldGroupMeta!]!
  initialSort: KeystoneAdminUISort
  isHidden: Boolean!
  isSingleton: Boolean!
}

type KeystoneAdminUIFieldMeta {
  path: String!
  label: String!
  description: String
  isOrderable: Boolean!
  isFilterable: Boolean!
  isNonNull: [KeystoneAdminUIFieldMetaIsNonNull!]
  fieldMeta: JSON
  viewsIndex: Int!
  customViewsIndex: Int
  createView: KeystoneAdminUIFieldMetaCreateView!
  listView: KeystoneAdminUIFieldMetaListView!
  itemView(id: ID): KeystoneAdminUIFieldMetaItemView
  search: QueryMode
}

enum KeystoneAdminUIFieldMetaIsNonNull {
  read
  create
  update
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  read
  hidden
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode
  fieldPosition: KeystoneAdminUIFieldMetaItemViewFieldPosition
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  read
  hidden
}

enum KeystoneAdminUIFieldMetaItemViewFieldPosition {
  form
  sidebar
}

type KeystoneAdminUIFieldGroupMeta {
  label: String!
  description: String
  fields: [KeystoneAdminUIFieldMeta!]!
}

type KeystoneAdminUISort {
  field: String!
  direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}
